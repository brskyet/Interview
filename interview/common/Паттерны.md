# Использованные паттерны
Паттерны бывают *порождающие, структурные, поведенческие*.

# Паттерны проектирования
## Порождающие
- *Фабричный метод*. Реализация: есть интерфейс с методом, который возвращает созданный объект. Тонкости создания объектов лежат на самом классе. Применялось для *кладовок. Способ получения кладовок мог меняться. *
- Абстрактная фабрика. Нужно использовать когда есть необходимость создавать семейства взаимосвязанных объектов и так же как и в обычной фабрике тонкости создания лежат на дочерних классах.
- Builder. Применяется если нужно создать комплексный объект шаг за шагом. И необходимо иметь возможность создавать разные объекты включая/выключая определенные шаги. Реальный пример - создание отчетов.
- Prototype. Позволяет создавать новые объекты путем клонирования уже существующих. Нужен когда стандартные 
- AddSingleton c натяжкой это *Singleton*, разве что в случае с DI единственный экземпляр будет на каждый вызов BuildServiceProvider().

## Поведенческие
- *Chain of Responsibility* - каждый объект-обработчик в цепочке может самостоятельно обработать запрос или передать следующему обработчику в цепочке. Реализация - общий интерфейс, который определяет метод обработки запроса и конкретные обработчики. Применяется когда важно обеспечить гибкость обработки запроса и декомпозицию на разные модули. Пример IRL - *расчет РСД по разным правилам по цепочке*
- *State* - Позволяет изменять поведение объекта в зависимости от его состояния. Реализация - класс-контекст, содержащий в себе состояние и делегирующий выполнение операций соответствующим для определенных состояний классам. Применять надо когда в коде много проверок на состояние и из-за этого появляется дублирование кода, а также когда необходимо добавлять новые состояния без изменения бОльшей части существующего кода. Использовал *для тг ботов*

## Без категории
- Specifications
- Transactional outbox. Когда использовать: есть микросервисная система, в которой для выполнения операции необходимо сделать несколько записей в БД и отправить несколько событий. При записи в базу мы одновременно пишем событие в некую таблицу из которой некий бекграунд сервис будет пулять события в брокера сообщений. Таким образом мы гарантируем, что следующий этап обработки начнется только при полном успешном завершении предыдущего этапа. Когда каждый этап обрабатывается отдельным микросервисом - это может быть удобно.

# Архитектурные паттерны
**CQRS (Command Query Responsibility Segregation).** Команды меняют состояние системы, запросы - получают данные. При обработке команд реализуется валидация, бизнес логика и обновление состояния системы. После успешного выполнения команды генерируются связанные события.
  Полезен, когда присутствует сложная бизнес логика, имеется event sourcing и микросервисы. Разделение запросов и команд тоже может быть выгодно. Вплоть до того, что можно держать две базы, одна для чтения, другая для записи, но это уже имхо перебор.
  
---

[**DDD**](https://backendinterview.ru/architecture/ddd.html). Основной акцент на домене, то есть предметной области. При проектировании важно соблюдать правило, что слой бизнес логики не зависит ни от кого, а все остальные слои должны зависеть от домена. Также существует разделение на entity и value objects. Entity это объекты с уникальном идентификатором, как правило имеют представление в БД. Также с точки зрения команды важно придерживаться Common Language. Применяется для сложной бизнес логики, не стоит применять, когда нужна максимальная скорость работы. Огромный плюс для тестирования, можно по сути в основном тестить только домен и не париться с моками и стабами.

**Ubiquitous Language (Единый язык)**.  Это язык, созданный целостной командой – экспертами в предметной области, разработчиками, бизнес-аналитиками и всеми, кто вовлечен в создание системы. Это общий набор терминов, понятий и фраз, который будет использоваться в общении между членами команды, и который позже отразится в исходном коде результирующей программы.
**Bounded Context (Ограниченный контекст)**. Это явная граница, внутри которой существует модель предметной области, которая отображает единый язык в модель программного обеспечения.
-   В каждом ограниченном контексте существует только один `единый язык`.
-   Ограниченные контексты являются относительно небольшими, меньше чем может показаться на первый взгляд. `ограниченный контекст` достаточно велик только для единого языка изолированной предметной области, но не больше.
-   Единый значит «вездесущий» или «повсеместный», т. е. язык, на котором говорят члены команды и на котором выражается отдельная модель предметной области, которую разрабатывает команда.
-   Язык является единым только в рамках команды, работающей над проектом в едином ограниченном контексте.
-   Попытка применить `единый язык` в рамках всего предприятия или что хуже, среди нескольких предприятий, закончится провалом.
**Предметная область (Domain)**. Это то, что делает организация, и среда, в которой она это делает. Разработчик программного обеспечения для организации обязательно работает в ее `предметной области`. Следует понимать, что очень важно разделять модели на логические разделенные `предметные подобласти` (Subdomain) всей `предметной области`, согласно их фактической функциональности. `Подобласти` позволяют быстрее определить разные части `предметной области`, необходимые для решения конкретной задачи
**Смысловое ядро (Core domain)**. `Смысловое ядро` – это `подобласть`, имеющая первостепенное значение для организации. Со стратегической точки зрения бизнес должен выделяться своим `смысловым ядром`. Большинство инвестиций должны быть направлены именно сюда для достижения преимущества для бизнеса и получения наибольшей прибыли.

**Тактическое проектирование**.
*Entity*
Если какое-то понятие предметной области является уникальным и отличным от всех других объектов в системе, то для его моделирования используется `сущность`. Такие `объекты-сущности` могут сильно отличаться своей формой за весь цикл существования, тем не менее их всегда можно однозначно идентифицировать и найти по запросу. Для этого используются уникальные идентификаторы, создание которых необходимо продумать в первую очередь при проектировании `сущности`.
*Value Object*
Если для объекта не важна индивидуальность, если он полностью определяется своими атрибутами, его следует считать `объектом-значением`. Чтобы выяснить, является ли какое-то понятие `значением`, необходимо выяснить, обладает ли оно большинством из следующих характеристик:
-   Оно измеряет, оценивает или описывает объект предметной области;
-   Должен быть неизменяем (immutable): при попытке обновления значения свойств мы должны создать и вернуть новый экземпляр VO
-   Оно моделирует нечто концептуально целостное, объединяя связанные атрибуты в одно целое;
-   При изменении способа измерения или описания его можно полностью заменить;
-   Его можно сравнивать с другими объектами с помощью отношения равенства `значений`. Два VO считаются одинаковыми тогда и только тогда, когда все поля VO равны
-   Оно предоставляет связанным с ним объектам `функцию без побочных эффектов`.
-   Состоит только из других VO и примитивов(не может содержать сущность или сервис)
-   Должен содержать в себе логику самовалидации: нельзя невалидный VO, исключение должно выкидываться прямо из метода VO(конструктор или клон).

*Domain Event*
Событие — это то, что произошло в прошлом. Логически, событие предметной области — это то, что произошло в конкретной предметной области, и то, о чем должны быть в курсе и на что должны реагировать другие части той же предметной области. Должны быть иммутабельными(так как нельзя менять прошлое). Название должно описывать случившиеся в прошлом событие.

*Aggregate*
`Агрегатом` называется кластер из объектов `сущностей` или `значений`. То есть эти объекты рассматриваются как единое целое с точки зрения изменения данных. У каждого `агрегата` есть корень `Aggregate Root` и граница, внутри которой всегда должны быть удовлетворены инварианты.
Все обращения к `агрегату` должны осуществляться через его `корень`, который представляет собой `сущность` с глобально уникальным идентификатором. Все внутренние объекты `агрегата` имеют только локальную идентичность, они могут ссылаться друг на друга как угодно. Внешние объекты могут хранить только ссылку на `корень`, а не на внутренние объекты.

*Factory*
Некоторые агрегаты или сущности могут быть достаточно сложными. Сложный объект не может создавать сам себя посредством конструктора.
Лучше выполнять создание сложных агрегатов или других объектов отдельно. Для этого используются фабрики. Фабрики – элементы программы, обязанности которого создавать другие объекты.

*Repository(Репозиторий)*
Репозиторий используется для `агрегатов`. Помещая `агрегат` в соответствующий Репозиторий, а затем извлекая его оттуда, вы получаете целостный объект. Если `агрегат` будет изменен, то изменения будут сохранены. Если `агрегат` будет удален, то его уже нельзя будет извлечь.
Каждый `агрегат`, предполагающий постоянное хранение, имеет свой Репозиторий. Зачастую в Репозитории реализуются методы для выборки полностью сгенерированных агрегатов по каким-то критериям.
Есть два типа Repository:
1.  Ориентированные на имитацию коллекций;
2.  Ориентированные на механизм постоянного хранения.

*Слои приложения*
- Presentation Layer. Слой приложения, где происходит взаимодействие с внешними системами. Например, это может быть слой с контроллерами для HTTP запросов или слой с механизмом приёма сообщений из брокера сообщений. 
- Application Layer. Здесь обрабатываются потоки бизнес-процессов. Например, здесь создаются и обновляются сущности домена. Также здесь могут решаться вопросы с управлением транзакциями. На этом уровне описывается выполнение команд как реакция на получение доменного события. Также с этого слоя может происходить обращение к Infrastructure Layer.
- Domain. Это уровень, куда включены все бизнес-правила, связанные с решаемой проблемой. В этом слое; будут иметь место сущности, объекты значений, агрегаты, фабрики и интерфейсы. Этот уровень должен быть максимально изолирован от зависимостей. Тут следует ограничить использование сторонних библиотек.
- Infrastructure Layer. Этот слой нужен для доступа к внешним службам, таким как базы данных, шина сообщений и службы электронной почты. Интерфейсы репозиторией , созданные на уровне домена и используемые на слое приложения, будут реализованы на этом слое.

**Богатая доменная модель (RDM) и анемичная доменная модель (ADM)**. ADM это по сути когда класс не содержит бизнес логику и описывает только сущность. То есть будет класс Person с полями для данных о человеке и класс PeopleService с бизнес логикой по работе с Person. RDM наоборот содержит значительную часть бизнес логики, валидаторов (например, имя не может быть длиннее 100 символов и т.д.).
Нарушает ли RDM SOLID, а именно Single Responsibility? С одной стороны класс делает много вещей, с другой они объединены общей сутью. Если модель слишком разрастается, то возможно плохо декомпозировали на сущности.
Нарушает ли ADM ООП? Думаю, что нарушает инкапсуляцию, потому что методы по работе с данными вынесены в другое место.
**Трилемма DDD** - между тремя характеристиками (полнота модели, чистота и производительность) можно реализовать только две в ущерб третьей.

---

**Event Sourcing.** Это про то, что можно рассматривать систему не через призму состояний данных в момент времени, а через призму событий, которые привели к данному состоянию. Таким образом состояния можно высчитывать впоследствии на основе событий. Позволяет очень дешево реализовывать undo/redo, логи доступа и т.д. Хорошо работает в паре с CQRS.
Слепок (snapshot). Если система существует давно и постоянно высчитывается на основе ивентов и их стало очень много, то она начнет тормозить. Тогда можно начинать высчитывать состояния не с самого начала, а с момента последнего слепка.

**Sagas**. Решает проблему распределенных транзакций. Реализуется с помощью набора локальных транзакций, когда каждый микросервис завершает свою часть работы и публикует событие, запускающее следующий этап.
Должны быть предусмотрены компенсирующие действия для отмены предыдущих этапов, если текущий невозможно завершить.
Для координации сервисов существует два подхода - хореография и оркестрация.
1.  **Хореография**:
	-   Каждый участник саги знает о своем следующем шаге и о том, какое действие следует предпринять.
	-   Нет централизованного контроллера или координатора. Вместо этого каждый участник решает, какой шаг следует предпринять далее на основе событий, которые он получает.
	-   Службы слушают события от других служб и реагируют на них, выполняя свои действия и отправляя дальнейшие события.
	-   Хореография часто связана с событийно-ориентированными системами.
2.  **Оркестрация**:
	-   Есть централизованный координатор или директор, который управляет порядком выполнения шагов в саге.
	-   Координатор решает, какой шаг следует предпринять далее, и приказывает соответствующему участнику или службе выполнить этот шаг.
	-   Оркестрация часто связана с управлением рабочими процессами и инструментами рабочих процессов.
