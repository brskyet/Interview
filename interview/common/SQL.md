# Оптимизация запросов
- создать недостающие индексы/перестроить запрос так, чтобы он использовал существующие
- убрать ненужные поля из выборки select, точно не делать `select *`
- избегать `select distinct`, т.к. уникальность достигается через group by
- where более оптимальный вариант, чем having
- использовать limit или top
- удалять неиспользуемые индексы
- иногда OR лучше заменить на два разных запроса и объединить с помощью UNION
- избегать использования слишком большого количества JOIN. Иногда лучше запустить несколько запросов отдельно
- избегать использования hint там, где это возможно
- не джойнить через where (это когда в FROM перечисляются несколько таблиц и потом в конце `WHERE d.DepartmentID = edh.DepartmentID`)
- иногда помогает обновить статистику
- решение не относящееся напрямую к БД - внедрить решение по кэшированию, чтобы снизить количество запросов к базе

# План запросов
- обычно в плане запроса можно увидеть подсказки, что не помешало бы создать определенный индекс

# ACID
Atomicity (атомарность) — выражается в том, что транзакция должна быть выполнена целиком или не выполнена вовсе.

Consistency (согласованность) — гарантирует, что по мере выполнения транзакций, данные переходят из одного согласованного состояния в другое, то есть транзакция не может разрушить взаимной согласованности данных. 

Isolation (изолированность) — локализация пользовательских процессов означает, что конкурирующие за доступ к БД транзакции физически обрабатываются последовательно, изолированно друг от друга, но для пользователей это выглядит, как будто они выполняются параллельно. 

Durability (долговечность) — устойчивость к ошибкам — если транзакция завершена успешно, то те изменения в данных, которые были ею произведены, не могут быть потеряны ни при каких обстоятельствах.

# Индексы
По умолчанию под капотом это B-tree. Кластеризованный - может быть только один, по сути это и есть отсортированная таблица. Лучше делать на то поле, которое редко изменяется, например, на ID. Некластеризованный - может быть сколько угодно. Также бывают уникальные, составные, покрывающие.
Селективность индекса - процент повторяющихся записей в индексе. Если < 5%, то есть смысл делать индекс. Если повторяющихся записей много, то сервер будет делать полный скан таблицы, не используя индекс. Индекс будет только мешать в таком случае.

# INCLUDE зачем нужен
При создании некластеризованных индексов можно использовать INCLUDE для создания покрывающих индексов. Поля, включенные через INCLUDE не будут использоваться при фильтрации, например, через WHERE. Однако, если запрос в SELECT будет содержать только данные, включенные в индекс через INCLUDE, то не нужно будет обращение напрямую к таблице и запрос ограничится обращением только к индексу, что ускорит запрос.

# Триггеры
Минусы триггеров:
- увеличение нагрузки на БД, т.к. они постоянно вызываются при изменении таблицы
- триггеры зачастую вызывают много блокировок, что также вызывает проблемы с производительностью

# CONSTRAINT
Ограничения для поля. Например, UNIQUE - уникальное значение, PRIMARY KEY - первичный ключ, FOREIGN KEY - внешний ключ, ON UPDATE CASCADE - каскадное обновление связанной таблицы при обновлении исходной. ON DELETE SET NULL - установка NULL для поля в случае удаления записи связанной таблицы.

# Вложенные транзакции
```sql
BEGIN TRANSACTION
   BEGIN TRANSACTION
      -- Что-то делаем
   COMMIT
ROLLBACK
```

По итогу ничего не закоммитится. Где может встретиться в реальной жизни? При вызове хранимки в другой хранимке, например.

# Транзакции
[Wikipedia](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9), [Geekbrains](https://geekbrains.ru/posts/acid_cap_transactions), [Medium](https://medium.com/pseudo-blog/%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B8-%D0%B8%D0%B7%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D0%B8-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9-87cd2b129de1), [какой-то блог чувака на английском](https://vladmihalcea.com/write-skew-2pl-mvcc/), [плейлист видосов](https://www.youtube.com/watch?v=4aa1lRShrrg&list=PLmqFxxywkatR3Psg4pz0Br0uDHzjR9Sne&index=1).

Транзакция — это набор действий с данными, объединенный в логическую единицу. Она либо выполняется целиком, либо отменяется полностью.

---
**Уровни изоляции:**
Для того, чтобы две транзакции не могли использовать одни и те же данные, существует изоляция. Изоляция – довольно дорогая штука. Нужно уметь правильно находить компромисс между изолированностью данных и быстродействием.

*Read uncommitted* (Чтение неподтверждённых данных). Блокировка данных на время выполнения транзакции, то есть следующая транзакция сможет записать изменения только после окончания предыдущей. Но при этом чтение данных возможно даже до окончания работы транзакции.

*Read committed* (Чтение подтверждённых данных). Запрет на чтение данных, над которыми ещё работает транзакция. Но при этом две транзакции могут мешать друг другу, выполняясь одновременно. Реализуется это с помощью либо блокирования, либо версионности. 

*Repeatable read* (Повторяемое чтение). Транзакция может видеть только те изменения, которые она сама внесла. Другие транзакции не могут изменять данные, читаемые текущей транзакцией, пока та не будет завершена. Другие транзакции могут вставлять новые строки, которые будут выдаваться при совершенном запросе. Если в рамках текущей транзакции произойдет ещё один аналогичный запрос, там могут оказаться данные, которых при первом запросе не было. Это называется фантомным чтением.

*Serializable* (Сериализуемый). Транзакции полностью изолируются друг от другая. Каждая выполняется так, как будто параллельных транзакций не существует, как будто все они выполняются последовательно. 

*Snapshot* (Версионирование). Транзакция будет работать с версией данных, которая зафиксирована на начало транзакции, вне зависимости от того, какие действия далее происходят с данными.

![[../../../attachments/Pasted image 20231029230756.png]]

---

**Подходы к реализации уровней изоляции.**

*Версионирование* (snapshot) означает, что транзакции будут работать со своей копией данных, не влияя друг на друга, но впоследствии несколько изменённых копий надо будет как-то слить в одну. Строгость версионирования регулирует моменты (когда) и размеры (сколько данных копировать) этих копий. 
Этим обеспечивается бо́льшая скорость работы, так как нет блокировки, но также требует бо́льшего количества оперативной памяти, т.к. надо хранить версии строк. Иногда слить в одну все копии не выйдет, так что часть транзакций придется отменить.

*Блокирование* (lock) означает, что одна транзакция будет ждать другую, чтобы избежать побочных эффектов, в зависимости от строгости уровней изоляции этих транзакций. Различные виды блокировок обеспечивают более гранулярное блокирование, например, только по строкам, или только на небольшой кусочек транзакции, а не на всю. Блокировки бывают:
-   Пессимистичная блокировка происходит как можно раньше, чтобы предотвратить как можно больше побочных эффектов, но транзакции чаще ждут друг-друга. Например, блокирование на обновление строк, которые прочитала транзакция в режиме read committed — это пессимистичная блокировка, потому что она происходит, как только ваша транзакция прочитала строки, не смотря на то, будет ли их кто-то обновлять или нет.
-   Оптимистичная блокировка происходит как можно позже, чтобы транзакции реже ждали друг-друга. Плата за такой вид блокировки — необходимость обрабатывать “конфликт обновления”. Конфликт обновления происходит, например, когда первая транзакция прочитала строки и хочет их обновить, но другая транзакция их уже обновила — при оптимистичной блокировке эта ошибка возникнет в первой транзакции и её надо корректно обработать: как минимум, повторить транзакцию позже, как максимум, обработать ошибку прямо в коде транзакции.
  Этот вариант предусмотрен для EF через использование поля `RowVersion` или `Timestamp`. Это поле автоматически обновляется при каждом изменении записи. При попытке обновления записи EF Core сравнивает текущее значение поля `RowVersion` в базе данных с тем, которое было прочитано при последнем чтении. Если они не совпадают, это означает, что запись была изменена, и EF Core генерирует исключение `DbUpdateConcurrencyException`.
  Также можно использовать **Атрибут [ConcurrencyCheck]**: Этот атрибут можно применить к любому свойству сущности, чтобы EF Core рассматривал его как индикатор для оптимистичной блокировки. При сохранении изменений EF Core сравнивает значение этого свойства в базе данных с текущим значением. Если они не совпадают, генерируется исключение `DbUpdateConcurrencyException`.

---

**2PL** (Two-Phase Locking) – протокол, обеспечивающий выполнение сериализации (Serializable).

В нём используются два вида локов – shared (чтение) and exclusive (запись) locks. Shared lock – может быть установлен множеством транзакций в том случае, если не стоит exlusive lock на запись. Он предотвращает любые транзакции, которые хотят сделать запись. То есть запись возможно будет произвести только тогда, когда все операции чтения будут завершены. Другим операциям чтения shared lock не мешает. Exclusive lock, наоборот, может быть только один. Он запрещает как операции чтения, так и операции записи. При длинных транзакциях велика вероятность поймать dead lock. По умолчанию такой подход используется SQL-сервером. 

**MVCC** (Multi-Version Concurrency Control) – другой подход для реализации сериализации. Он заключается в том, что БД поддерживает одновременно несколько версий данных (снимков). Транзакции работают со снимками. Все снимки между собой согласованны. Снимок может определяться в момент начала транзакции (уровни repeatable read, serializable) или отдельно для каждой операции (уровень read committed)

---

**Аномалии/феномены связанные с ослаблением изоляции.**
Dirty Write – транзакция может изменять незакоммиченные данные прошлых транзакций. Про эту аномалию говорят редко, так как она нарушает не только изоляцию, но и атомарность. Блокируется такая аномалия очень просто. Когда транзакция начинает записывать изменения, на данные вешается лок. Снимается он только когда транзакция закончит выполнение.

Dirty Read – транзакции могут читать данные, которые были незакомиченны. Первый вариант решения проблемы – такой же как в прошлом феномене. Но это сильно бьет по производительности. Другой вариант – использовать данные, которые нужны для отмены (rollback) транзакции. Эти данные ещё не содержат изменений, которые внесены текущей транзакцией.

Lost Update – это ситуация, при которой одна транзакция затирает данные, которые были вписаны другой транзакцией. Имеется ввиду ситуация, когда первая транзакция внесла изменения, но не закоммитила, вторая тоже внесла изменения, и тем самым затёрла изменения первой. Решается блокировками. В SQL это выглядит как SELECT FOR UPDATE. Это вешает блокировку как на чтение, так и на запись. Но тут есть минус: мы тем самым блокируем все запросы, которые делают выборку, которая содержит эту запись. Таким образом можно заблокировать чуть ли не всю БД. Есть другое решение – SELECT FOR SHARE. Здесь мы позволяем данные читать, но не позволяем данные записывать. 

Cursor Lost Update. Курсор - это структура, в которой находятся записи из SELECT.  Мы можем по этой структуре итерироваться и выбирать одну отдельную запись. Это позволят использовать два вида локов:

Read stability – лок на всю выборку SELECT.

Cursor stability – лок только на ту строку, на которую указывает курсор.

Эти локи позволяют бороться с проблемой Lost Update, только в случае использования курсоров.

Non-Repeatable Read – если транзакция сделает выборку с условием, а одну из записей изменила другая транзакция, тогда если сделать повторную выборку, то получится иной результат. Для решения проблемы, мы можем явно повесить блокировку на записи из выборки. Либо БД может навешивать shared lock на данные из выборки. Либо MVCC механизм может проверить, что данные во время транзакции поменялись, и отменить выполнение всей транзакции.

Phantom Read – это происходит тогда, когда мы позволяем текущей транзакции видеть данные, добавленные другими транзакциями. Отличие от NON-REPEATABLE READ в том, что строки, которые мы уже разок прочитали остаются такими же, соответственно здесь нет NON-REPEATABLE READ. Но при этом, запрос который сначала вернул 5 строк, может вернуть эти же пять строк, плюс ещё две свежие строки из другой транзакции.

В 2PL это решается локами. В MVCC отменяются транзакции, которые могли быть нарушены вставками.

Read Skew (Скос по чтению) – Возникает во время работы с несколькими таблицами, работа с которыми должна быть согласована. Это по сути частный случай non-repeatable read, лечится примерно так же.

Write Skew (Скос по записи) – Это когда транзакция делает проверку на данные, которые могут быть изменены другой транзакцией. То есть две транзакции проверяют один и тот же параметр, у двух транзакций условие срабатывает, а затем обе транзакции изменяют состояние строки, хотя можно было только одной. Тот же non-repeatable read, лечится локами.

![[../../../attachments/Pasted image 20231029231330.png]]