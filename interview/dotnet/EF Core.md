###### Кэш
Когда объекты загружаются в контекст Entity Framework через операции, такие как Find, Where или ToList, эти объекты автоматически кэшируются в контексте.
Если вы попытаетесь получить доступ к тем же данным в пределах этого контекста, EF будет использовать кэшированную версию этих объектов вместо выполнения нового запроса к базе данных.
Этот кэш существует только в пределах жизненного цикла конкретного экземпляра контекста. Когда контекст уничтожается или освобождается, кэш также уничтожается.
Из-за этого могут возникать проблемы, т.к. в некоторых случаях EF может брать неактуальные уже данные из кэша. Чтобы этого избежать - можно сбросить кэш методом Reload. Либо использовать DbContext с коротким временем жизни

###### Changes tracker
Это механизм, который позволяет EF Core отслеживать и фиксировать изменения, произошедшие с сущностями после их загрузки из базы данных. Есть пять основных состояний: Added, Modified, Deleted, Unchanged и Detached.
`AsNoTracking` указывает, что результаты запроса не должны быть отслеживаемыми. Это может улучшить производительность при чтении данных, когда изменение или сохранение данных не требуется. `AsTracking` делает результаты запроса отслеживаемыми (это поведение по умолчанию).

###### Каким образом оптимально сделать bulk insert через EF Core?
1. Выключить автоматическое отслеживание
2. Использовать ExecuteUpdate, ExecuteDelete для обновления или удаления пачкой
3. Использовать стороннюю либку **EFCore.BulkExtensions**
4. Использовать RawSQL
При дефолтном поведении EF чаще всего будет производить вставку каждого элемента по одному

###### DbContext
При регистрации в DI DbContextFactory регистрируется как Singleton, а DbContext - Scoped 