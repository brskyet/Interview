[Статья с вопросами](https://dev.to/bytehide/c-multithreading-interview-questions-and-answers-4opj)
# Разница между использованием  _ThreadPool_ и созданием своих потоков.
- ThreadPool менее ресурсозатратный. В ThreadPool потоки переиспользуются для разных задач, следовательно не нужно их создавать и уничтожать постоянно.
- Время жизни потоков в ThreadPool регулируется системой, тогда как вручную созданные потоки контроллируются разработчиком
- ThreadPool автоматически регулирует количество созданных потоков
- Потоки в ThreadPool имеют дефолтную приоритетность. В пользовательских потоках можно настраивать это по-иному
-  Очередность выполнения задач в ThreadPool настраивается автоматически. В пользовательских потоках надо регулировать это вручную

ThreadPool using

```csharp
ThreadPool.QueueUserWorkItem((_) =>
{
    // Your task logic here.
});
```

Выделенный поток

```csharp
Thread thread = new Thread(() =>
{
    // Your task logic here.
});
thread.Start();
```

---
**Взаимное исключение** (англ. _mutual exclusion_) — свойство построения параллельных программ, которое используется в целях предотвращения состояния гонки (англ. _race condition_); Оно требует, чтобы один поток исполнения никогда не входил в критическую секцию одновременно с тем, как другой параллельный поток выполнения вошел в свою критическую секцию.

# Как обеспечить взаимное исключение для доступа к общим ресурсам не используя lock и Monitor

###### Mutex
Позволяет синхронизировать между процессами. Только один поток может получать доступ к ресурсу в единицу времени.
```csharp
 Mutex mutex = new Mutex();
  //...
  mutex.WaitOne();
  try
  {
      // Access shared resource
  }
  finally
  {
      mutex.ReleaseMutex();
  }
```
###### Semaphore
Позволяет получать более чем одному потоку доступ к ресурсам, а также ставить предельное значение потоков.
```
Semaphore sem = new Semaphore(1, 1); // Initial and maximum count set to 1
  //...
  sem.WaitOne();
  try
  {
      // Access shared resource
  }
  finally
  {
      sem.Release();
  }
```
###### ReaderWriterLockSlim
Позволяет множеству потоков одновременно производить чтение, если в данный момент не идет запись. Запись только по одному.
```csharp
 ReaderWriterLockSlim rwLock = new ReaderWriterLockSlim();
  //...
  // Read access
  rwLock.EnterReadLock();
  try
  {
      // Access shared resource
  }
  finally
  {
      rwLock.ExitReadLock();
  }
  //...
  // Write access
  rwLock.EnterWriteLock();
  try
  {
      // Access shared resource
  }
  finally
  {
      rwLock.ExitWriteLock();
  }
```
###### SpinLock
Нужно использовать тогда, когда нужно залочить секцию кода на очень короткое время
```csharp
  SpinLock spinLock = new SpinLock();
  bool lockTaken = false;
  //...
  spinLock.Enter(ref lockTaken);
  try
  {
      // Access shared resource
  }
  finally
  {
      if (lockTaken)
      {
          spinLock.Exit();
      }
  }
```
---
# Разница между Barrier и CountdownEvent с примерами использования
###### Barrier
Позволяет нескольким потокам работать одновременно, пока они не дойдут до определенной точки. Каждый поток ждет, когда все потоки дойдут до этой точки и после этого одновременно продолжают выполнение следующего этапа.
*Но по факту async/await проще заюзать*
Пример: применение фильтра на картинку
```
int participants = 3;
Barrier barrier = new Barrier(participants);
Parallel.ForEach(filters, filter =>
{
    // Apply filter on the image
    // ...
    barrier.SignalAndWait(); // Wait for other filters to complete
});
```
###### CountdownEvent
Блокирует потоки пока счетчик не дойдет до нуля.
Пример: загрузка контента по частям и количество частей известно.
```csharp
int fileCount = 5;
CountdownEvent countdown = new CountdownEvent(fileCount);

// Downloader threads
for (int i = 0; i < fileCount; i++)
{
    new Thread(() =>
    {
        // Download file
        // ...
        countdown.Signal();
    }).Start();
}

// Worker thread waits for all files to be downloaded
countdown.Wait();
// Process downloaded data
```
# Что будет если вызвать Thread.Abort(), чтобы завершить поток
- Выбросится исключение, которое может оставить общие ресурсы, данные в БД и т.д. в неконсистентном состоянии
- Утечка ресурсов, т.к. стримы могут не закрыться и т.д.
- Deadlock. Примитивы синхронизации могут не освободиться
- ThreadAbortException Handling. Если есть хэндлинг, то поток продолжит работу

 Чтобы правильным образом обрабатывать остановку потока, можно использовать **CancellationToken**

# ReaderWriterLockSlim и его преимущества перед ReaderWriterLock
Много параллельных чтений, если нет записей. Записи по одному. Не поддерживает кросс-процессную синхронизацию. Mutex поддерживает.
```csharp
ReaderWriterLockSlim rwLock = new ReaderWriterLockSlim();

// Reading data
rwLock.EnterReadLock();
try
{
    // Access shared resource for reading
}
finally
{
    rwLock.ExitReadLock();
}

// Writing data
rwLock.EnterWriteLock();
try
{
    // Access shared resource for writing
}
finally
{
    rwLock.ExitWriteLock();
}
```

Преимущества перед ReaderWriterLock
- Лучше производительность
- Позволяет работать с рекурсиями, т.е. несколько раз входить и выходить из лока.
- Избегание Writer Starvation. Возможно дать приоритет для операций записи, чтобы они выполнялись первыми.

# Разница между Semaphore и SemaphoreSlim
- SemaphoreSlim оптимизирован для сценариев, когда ожидание происходит преимущественно на короткое время. Он обеспечивает более быструю и менее ресурсоемкую реализацию по сравнению с Semaphore.
- SemaphoreSlim не поддерживает синхронизацию между процессами.
- SemaphoreSlim единственный может использоваться с async/await.

# Различия Tasks и Threads.
- Tasks в ThreadPool более эффективно управляет ресурсами.
-  Время жизни Tasks управляется системой
- Tasks поддерживаются в асинхронном программировании
- Для Tasks удобнее выстраивать цепочку вызовов через ContinueWith(). Для Threads придется синхронизировать самостоятельно.
- Отмена работы. Tasks поддерживают CancellationToken, для Threads придется реализовывать логику с флагами или что-то ещё
- Tasks обеспечивают лучшую обработку исключений, агрегируя исключения из множества  тасков и распространяя их по цепочке вызова.

По итогу использовать потоки надо разве что там, где требуется возможность кастомизации.

# Разница между Volatile, Interlocked и MemoryBarrier методами использования переменных в многопоточке
###### Volatile
Ключевое слово, сообщающее, что переменную не надо кэшировать, а всегда надо читать и писать в основную память. Таким образом каждый поток получит максимально актуальное значение. Также это означает, что несколько потоков могут изменять поле.
Используется когда к переменной будут обращаться несколько потоков без локов и нам нужно обеспечить правильную работу с памятью.
```csharp
 private volatile bool stopRequested;

  // In one thread
  stopRequested = true;

  // In another thread
  if (!stopRequested)
  {
      // Perform work
  }
```
###### Interlocked
Предоставляет операторы типа Add, Increment, Decrement, Exchange и CompareExchange (Сравнивает два значения на равенство и, если они равны, заменяет первое) для shared переменных. Это неблокирующие операции.
Используется когда нужны простые операции на shared переменных без локов.

```csharp
  private int counter = 0;

  // Increment counter atomically
  Interlocked.Increment(ref counter);
```
###### MemoryBarrier
Предотвращает изменение порядка доступа инструкций к памяти таким образом, что инструкции до барьера не могут выполняться позже тех, что идут после барьера.
Используется редко.
```csharp
  private int value1 = 0;
  private int value2 = 0;

  // In one thread
  value1 = 1;
  Thread.MemoryBarrier();
  value2 = 2;

  // In another thread
  int localValue2 = value2;
  Thread.MemoryBarrier();
  int localValue1 = value1;
```
# ThreadLocal и Data partitioning
###### ThreadLocal 
Позволяет каждому потоку работать со своей локальной копией переменной. Инициализируется заново для каждого потока. Улучшает производительность т.к. нет издержек на синхронизацию потоков для доступа к переменным.

```csharp
ThreadLocal<int> localSum = new ThreadLocal<int>(() => 0);

// Each thread can safely use and modify its localSum without synchronization.
localSum.Value += 1;
```
###### Data Partitioning
Секционирование данных - разделение коллекции на более мелкие части (партиции) и обработка каждой в отдельном потоке. Помогает улучшить производительность за счет более эффективного использования ресурсов.
```csharp
List<int> data = new List<int> { ... };
Parallel.ForEach(data, item =>
{
    // Process item
});
```

# Как работает CancellationToken?
Данная модель позволяет отменять таски по запросу.
Пошаговый гайд для использования модели cancellation в TPL:
1. Создание объекта CancellationTokenSource. Он ответственен за генерацию и управление CancellationToken
2. Получить инстанс CancellationToken из CancellationTokenSource. CancellationToken передает запрос отмены выполняемому таску
3. Передать CancellationToken в таск
4. В таске с некой периодичностью проверять флаг в токене
5. Когда таск видит запрос об отмене, он должен очистить ресурсы и закончить работу
6. Чтобы запросить отмену необходимо вызвать CancellationTokenSource.Cancel() метод

```csharp
CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();
CancellationToken cancellationToken = cancellationTokenSource.Token;

Task task = Task.Run(() =>
{
    // Example of a long-running task
    for (int i = 0; i < 1000000; i++)
    {
        // Check for cancellation
        cancellationToken.ThrowIfCancellationRequested();

        // Perform task work
    }
}, cancellationToken);

// After some time, when a cancellation is needed
cancellationTokenSource.Cancel();
```

# Как комбинировать асинхронную модель программирования и многопоточную?
- Используй async/await с Task.Run() или другими методами, которые возвращают Task, чтобы запланировать задачу в отдельном потоке
- Используй Task.WhenAll() или Task.WhenAny(), чтобы скоординировать несколько асинхронных задач
- Используй TaskScheduler для контроля очередности выполнения задач

```csharp
public async Task PerformWorkAsync()
{
    // Start two tasks running concurrently
    Task task1 = Task.Run(() => PerformIntensiveWork());
    Task task2 = Task.Run(() => PerformAdditionalIntensiveWork());

    // Wait for both tasks to complete
    await Task.WhenAll(task1, task2);

    // Continue processing results
}
```

# lock
lock - это оболочка вокруг Monitor.Enter и Monitor.Exit. И Enter и Exit должны быть вызваны в рамках одного потока, чтобы всё работало корректно. 
**Почему нельзя делать await внутри lock?**
Код, выполняемый после await может быть выполнен в другом потоке. В качестве объекта для синхронизации можно использовать только ссылочные типы, потому что значимые копируются полностью и тогда для каждого потока будет просто своя копия и они не смогут синхронизироваться.

```csharp
lock (lockObject)
{
    await Task.Delay(1000);
}
```

Также надо помнить, что await не может встречаться в теле синхронной функции, в query expression, в области действия блокировки или в небезопасном контексте.

Если есть вложенные вызовы методов и каждый внутри использует lock на одном и том же объекте, то ничего плохого не произойдет, если все вызовы методов происходят в одном и том же потоке. Дело в том, что внутри объекта синхронизации в специальное поле записывается номер потока, у которого есть сейчас доступ к критической секции кода. И если во вложенном вызове метода произойдет lock на тот же самый объект, то код просто продолжит выполнение. Кстати, поэтому структуры весят меньше классов, в том числе потому что это значимый тип и там нет этого поля для синхронизации потоков.

# Общие рекомендации для выбора примитива синхронизации
Если нет async/await, то оптимальнее всего работает Monitor, то есть lock. 
Если встречается await, то лучше всего SemaphoreSlim. При этом якобы вообще не будет происходить блокировок, результат будет достигнут с помощью изменения очередности выполнения Task'ов. То есть в момент вызова метода Release() происходит разблокировка следующего в очереди задания.

# PLINQ AsParallel использовать в начале или в конце LINQ цепочки?
AsParallel() оборачивает обычный IEnumerable в IParallelEnumerable и таким образом экстеншн методы для PLINQ будут работать только после AsParallel(), а до него будут применяться обычные. То есть AsParallel() надо использовать как можно раньше.

# Async void method
Не стоит делать async метод void, т.к. при исключении ляжет весь процесс и приложение в целом, что нам явно не нужно.

# ConfigureAwait
ConfigureAwait(true): Гарантирует, что после завершения операции await, выполнение продолжится в том же контексте синхронизации, из которого был вызван асинхронный метод. Это поведение по умолчанию для await.
ConfigureAwait(false): Указывает, что после завершения операции await, выполнение не должно продолжаться в том же контексте синхронизации.

# async/await
**async** указывает компилятору, что метод может содержать ключевое слово await
Когда выполнение метода достигает **await**, текущий метод приостанавливает выполнение до тех пор, пока не завершится задача. При этом поток не блокируется и возвращает управление внешнему коду. При этом метод преобразуется в конечный автомат.
Есть разница между тем, когда идет обращение к внешним источникам, например, БД через await и вызовом метода с вычислениями. В первом случае поток возвращается в пул потоков и затем, когда ОС уведомляет приложение, что мы получили ответ, продолжается выполнение кода. В случае, если происходят вычисления в методе, то поток продолжает заниматься работой.
То, будет ли асинхронный метод выполняться в том же потоке или в другом после `await`, зависит от нескольких факторов:
1.  **Синхронизационный контекст**
	-   Если текущий синхронизационный контекст (например, UI контекст в Windows Forms или WPF) доступен и не `null`, `await` по умолчанию будет пытаться выполнить продолжение в этом контексте, т.е. на том же потоке.
	-   Если синхронизационного контекста нет, продолжение будет запланировано на поток из пула потоков.
2. **Конфигурация Await**:
	- Вы можете использовать `ConfigureAwait` для управления поведением `await`. Если вы вызываете `ConfigureAwait(false)`, вы явно указываете, чтобы продолжение не возвращалось к текущему синхронизационному контексту, и оно может выполняться на любом доступном потоке.
3. **Статус задачи**:
	- Если задача уже выполнена, то выполнение продолжается далее в том же потоке.
Контекст синхронизации не всегда ассоциируется с конкретным потоком. Обычно для UI контекст связан с основным потоком и ConfigureAwait(true) вернет выполнение этому потоку. А, например, в ASP.NET это не так, поэтому гарантии возврата нет.

# Что такое ValueTask и как он отличается от Task?
ValueTask – это структура, представляющая асинхронную операцию, которая может не выделять память на куче. В отличие от Task, которая всегда является ссылочным типом, ValueTask может представлять результат как на куче, так и на стеке.
ValueTask рекомендуется использовать в сценариях, где асинхронные методы часто завершаются синхронно и где накладные расходы на аллокацию Task могут быть проблемой.
ValueTask нельзя дожидаться выполнения несколько раз.
Используется в EF, например, в методах FindAsync(), AddAsync().
# Потокобезопасные коллекции
[Почитать можно тут](https://learn.microsoft.com/ru-ru/dotnet/standard/collections/thread-safe/)

| Type                              | Описание                                                                                                                                                                                                        |
| --------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| BlockingCollection\<T\>           | Предоставляет возможности блокировки и ограничения для всех типов, реализующих интерфейс IProducerConsumerCollection\<T\>. |
| ConcurrentDictionary<TKey,TValue> | Потокобезопасная реализация словаря пар "ключ-значение".                                                                                                                                                        |
| ConcurrentQueue\<T\>              | Потокобезопасная реализация очереди с типом "первым поступил — первым обслужен" (FIFO).                                                                                                                         |
| ConcurrentStack\<T\>              | Потокобезопасная реализация стека с типом "последним поступил — первым обслужен" (LIFO).                                                                                                                        |
| ConcurrentBag\<T\>                | Потокобезопасная реализация неупорядоченной коллекции элементов.                                                                                                                                                |
| IProducerConsumerCollection\<T\>  | Это интерфейс, тип которого должен быть реализован для использования в классе BlockingCollection.                                                                                                               |

