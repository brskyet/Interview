# Finalize и Dispose
- Finilaze() метод вызывается при уничтожении объекта GC
- Dispose() используется для очистки неуправляемых ресурсов и вызывается разработчиком вручную, либо через конструкцию using
# Зачем нужны брокеры сообщений
- Асинхронная коммуникация
- Гарантированная доставка сообщений. Особенно если использовать MassTransit
- Масштабируемость
- Сглаживание всплеска нагрузки, т.е. сервис будет разгребать сообщения так быстро как успевает
# DI
Зачем нужен DI? Помогает контролировать порождение объектов. Упрощает работу с зависимостями и тестирование. 
Чем можно заменить DI? Совокупностью порождающих паттернов, типа фабрики, билдера и т.д. Но, конечно, это гораздо менее удобно, хотя бы в плане количества кода.
# ref out in
**ref** - передача параметров по ссылке. При изменении параметра внутри метода изменения затронут оригинальный объект. 
**out** - передача параметра по ссылке и обязательство инициировать в методе переменную. 
**in** - передача параметра по ссылке без возможности модификации внутри метода. 
Если нужно передать параметр ссылочного типа таким образом, чтобы внутри метода нельзя было его изменить, придется сделать ручное копирование объекта или копирование методом Clone()
Использование модификатора **ref** для параметра ссылочного типа в C# позволяет методу изменять саму ссылку, а не только содержимое, на которое эта ссылка указывает.
# Перегрузка и переопределение
Перегрузка метода - одно и тоже название, но разная сигнатура. 
Переопределение - override, то есть замена поведения метода в наследуемом классе. При этом при приведении к родительскому типу будет вызвана также версия метода наследуемого класса. Метод базового класса должен быть объявлен как `virtual`, `abstract` или `override`.
new - тоже переопределение, но можно использовать без ключевых слов `virtual`, `abstract` или `override`. Также при приведению к родительскому типу будет вызвана версия метода родительского класса.

# Интерфейсы и абстрактные классы
Разница между интерфейсом и абстрактным классом:
- можно наследоваться только от одного абстрактного класса
- Абстрактный класс: Может содержать конструкторы, деструкторы, статические методы и поля.
- Члены абстрактного класса могут иметь модификаторы доступа.
Семантически интерфейс используется в качестве контракта, абстрактный класс - как класс, содержащий общую реализацию методов.
# Позднее связывание
Позднее связывание (или динамическое связывание) — это механизм, при котором вызов метода определяется во время выполнения программы, а не во время компиляции. Например
```csharp
Animal myDog = new Dog();
Animal myCat = new Cat();

myDog.Speak(); // Выводит "Woof!"
myCat.Speak(); // Выводит "Meow!"
```
# Замыкание
Замыкание в C# происходит, когда лямбда-выражение или делегат захватывает переменную из окружающего контекста. Это позволяет лямбда-выражению или делегату обращаться к этой переменной даже после того, как область видимости, в которой была объявлена переменная, завершила свою работу.
При использовании замыканий в циклах с LINQ часто возникают проблемы из-за того, что переменная цикла захвачена замыканием. Это может привести к неожиданным результатам, когда одна и та же переменная используется во всех итерациях.
Под капотом для каждого замыкания создается класс и все переменные захваченные замыканием становятся полями этого класса. Само лямбда выражение становится методом этого класса. При этом переменные сохраняются по ссылке, поэтому они могут жить дольше оригинальных переменных и реагировать на изменение оригинала.
# IEnumerable и IQueryable
Разницу между IEnumerable и IQueryable? 
IEnumerable предназначен для работы с коллекциями в памяти, в то время как IQueryable обычно используется для формирования запросов к источникам данных вне процесса (например, к базе данных), позволяя транслировать LINQ-запросы в запросы на другом языке (например, SQL).
# Строки
- **Что такое неизменяемость строк в .NET?** Строки в .NET являются неизменяемыми. Это означает, что после создания строки её значение не может быть изменено. Любые операции изменения строки (конкатенация, замена и т.д.) приведут к созданию нового объекта строки. Также две одинаковые строки хранятся в одной ячейке памяти.
-  **Как объединить несколько строк?**
    -  '+' :'string c = a + b;'
    -  'StringBuilder': используется для оптимизированного объединения строк, особенно в циклах. Под капотом у него массив чаров
    -  'String.Concat':'string result = String.Concat(a, b);'
    -  'String.Join': используется для объединения коллекции строк с определенным разделителем.
- **Как сравнивать строки?**
    -  'String.Equals': проверяет на равенство содержимое строк.
    -  '==': сравнивает ссылки на строки, но в C# для строк этот оператор перегружен, так что он сравнивает содержимое строк.
- **Что такое интерполяция строк и как ее использовать?** Интерполяция строк в C# позволяет вставлять значения переменных прямо в строку. Пример:'var message = $"Hello, {name}!";'
-  **Что такое строковый интернирование?** Это процесс хранения одной копии каждой уникальной строки в памяти для оптимизации производительности и использования памяти.
-  **Какие проблемы могут возникнуть при использовании строк в многопоточных приложениях?** В многопоточных приложениях особенно важно избегать чрезмерного создания строк из-за их неизменяемости. Операции, такие как'StringBuilder' в многопоточной среде, могут требовать синхронизации для предотвращения конфликтов.

Строковое интернирование в .NET применяется к строковым литералам в исходном коде на этапе компиляции. Это значит, что одинаковые строковые литералы в одном приложении будут ссылаться на одну и ту же область памяти. Однако строки, полученные из различных источников во время выполнения (например, из базы данных, из API или из файла), по умолчанию не будут интернированы. Каждая из этих строк будет занимать свою область в памяти, даже если их содержимое идентично.

Интернированные строки хранятся в специальной таблице, которая называется интерн-пулом (intern pool). Строки в этом пуле обычно существуют на протяжении всего времени жизни приложения, что означает, что они не будут собраны сборщиком мусора до тех пор, пока приложение не завершит свою работу. Это также означает, что использование интернирования строк во время выполнения может привести к увеличенному потреблению памяти, если множество уникальных строк интернируются и не освобождаются. Строки, интернированные с помощью *string.Intern()* так же живут до конца работы приложения.
Неинтернированные строки удаляются как и любые другие ссылочные объекты.

# Как создать кастомный атрибут
Чтобы реализовать настраиваемый атрибут в C#, выполните следующие действия:

1.  Создайте класс, производный от `System.Attribute` класса.
2.  Добавьте в класс свойства, поля или методы, необходимые для хранения метаданных.
3.  Примените атрибут к элементам вашего кода (например, классам, методам или свойствам), используя синтаксис атрибута.

Вот пример создания и использования пользовательского атрибута в C#:
```csharp
using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class CustomAttribute : Attribute
{
    private string _description;

    public CustomAttribute(string description)
    {
        _description = description;
    }

    public string Description => _description;
}

[Custom("This is a custom attribute applied to the example class.")]
class ExampleClass
{
    [Custom("This is a custom attribute applied to the example method.")]
    public void ExampleMethod()
    {
        // ...
    }
}
```

# Разница между ссылочными и значимыми типами
1.  **Место хранения**:
    -   **Значимые типы** хранятся в стеке (stack). Они представляют непосредственно значения.
    -   **Ссылочные типы** имеют переменную в стеке, которая указывает на объект в куче (heap).
2.  **Поведение при передаче**:
    -   **Значимые типы** передаются "по значению", что означает, что при передаче переменной создается копия ее значения.
    -   **Ссылочные типы** передаются "по ссылке", что означает, что при передаче переменной передается ссылка на один и тот же объект в памяти.
3.  **Жизненный цикл**:
    -   **Значимые типы** имеют фиксированный размер и уничтожаются автоматически, когда выходят из области видимости.
    -   **Ссылочные типы** управляются сборщиком мусора (garbage collector). Они уничтожаются, когда на них нет ссылок.
4.  **Null-значение**:
    -   **Значимые типы** по умолчанию не могут иметь значение `null`. Однако с помощью nullable-типов (например, `int?`) это становится возможным.
    -   **Ссылочные типы** могут иметь значение `null`, что означает отсутствие ссылки на объект.
5.  **Примеры**:
    -   **Значимые типы**: все числовые типы (`int`, `double`), `struct`, `bool`, `char`, `enum`.
    -   **Ссылочные типы**: `string`, `object`, массивы, делегаты, классы.
6.  **Изменяемость**:
    -   **Значимые типы**, такие как структуры, являются неизменяемыми по умолчанию.
    -   **Ссылочные типы**, такие как классы, являются изменяемыми.

# Классы vs структуры
1.  **Тип данных**:
    -   **Структуры** являются значимыми типами (value types).
    -   **Классы** являются ссылочными типами (reference types).
2.  **Место хранения**:
    -   **Структуры** обычно хранятся в стеке. Однако, если структура является членом класса, элементом коллекции или размещены в замыканиях (например, в лямбда-выражениях, которые захватывают внешние переменные), то будет хранится в куче.
    -   **Классы** хранятся в куче, а ссылка на класс хранится в стеке.
3.  **Поведение при передаче**:
    -   **Структуры** передаются по значению. Это означает, что при передаче или присваивании структуры создается копия этой структуры.
    -   **Классы** передаются по ссылке. При передаче или присваивании класса передается ссылка на один и тот же объект.
4.  **Null-значение**:
    -   **Структуры** не могут иметь значение `null` по умолчанию (за исключением nullable-структур).
    -   **Классы** могут иметь значение `null`.
5.  **Наследование**:
    -   **Структуры** не могут наследовать другие структуры или классы и не могут быть базовыми для классов.
    -   **Классы** могут наследовать другие классы и реализовывать интерфейсы.
6.  **Модификаторы**:
    -   **Структуры** не могут иметь деструкторы (finalizers) и не могут использовать модификатор `protected`.
    -   **Классы** могут иметь деструкторы и использовать модификатор `protected`.
7.  **Изменяемость**:
    -   Все поля структуры должны быть инициализированы перед использованием, так как структуры не имеют конструктора по умолчанию.
    -   Классы могут иметь конструктор по умолчанию.
8.  **Эффективность**:
    -   **Структуры** могут быть более эффективными в случаях, когда нужно быстро создавать и уничтожать небольшие объекты.
    -   **Классы** лучше подходят для ситуаций, когда объекты имеют больший жизненный цикл, большой размер или требуют наследования и полиморфизма.

# GC
**Какие есть поколения в сборщике мусора?** В .NET GC разделяется на три поколения: 0, 1 и 2. Новые объекты создаются в поколении 0. Если они продолжают существовать после сборки мусора, они "продвигаются" в следующее поколение.
**Как работает процесс сборки мусора?** GC начинает свою работу с проверки объектов в поколении 0. Если память переполнена, он продвигает объекты в следующее поколение и продолжает сборку мусора в следующем поколении.

Алгоритм работы сборщика мусора следующий:
1.  **Фаза маркирования (Mark)**: GC начинает со всех корневых объектов и рекурсивно проходит по всем доступным объектам, маркируя каждый достижимый объект.
2.  **Фаза очистки (Sweep)**: После завершения маркирования, GC проходит через все объекты в куче. Объекты, которые не были отмечены в фазе маркирования, считаются мусором, так как они больше не доступны для приложения. Эти объекты удаляются, и освобожденная память возвращается в кучу.
3.  **Фаза уплотнения (Compact)**: Не все реализации GC включают этот этап, но его цель - переместить оставшиеся объекты ближе друг к другу, уплотняя кучу и обеспечивая непрерывный блок свободной памяти.
Корневые объекты - это объекты, на которые ссылаются глобальные и статические переменные, а также локальные переменные и параметры методов, находящихся на стеке вызовов.

# yield
Оператор `yield` используется для создания итераторов в C#. Он позволяет генерировать элементы коллекции по одному, когда они запрашиваются, вместо того чтобы генерировать все элементы заранее. `yield return` возвращает следующий элемент коллекции. Выполнение метода приостанавливается и возобновляется с того же места при следующем запросе элемента. `yield break` завершает итерацию, указывая, что элементы коллекции закончились.
# Equals и GetHashCode
_Equals_ вызывается только тогда когда _GetHashCode_ возвращает одинаковые значения 
# Span
`Span<T>` — это [структура ссылки](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/builtin-types/ref-struct) , которая выделяется в стеке, а не в управляемой куче. Цель данного типа - повысить производительность и эффективность использования памяти. Span позволяет избежать дополнительных выделений памяти при операции с наборами данных.

Типы ссылочных структур имеют ряд ограничений, в том числе их нельзя упаковать, они не могут быть назначены переменным типа Object, `dynamic` или любому типу интерфейса, они не могут быть полями в ссылочных типах и не могут использоваться через `await` и `yield` . Кроме того, вызовы двух методов, Equals(Object) и GetHashCode, вызывают исключение [NotSupportedException](https://learn.microsoft.com/ru-ru/dotnet/api/system.notsupportedexception?view=net-7.0).


# Библиотеки, про которые спрашивали
[Fluent validation](https://docs.fluentvalidation.net/en/latest/) - библа для валидации через Fluent API
Hangfire - шедулер
Polly - реализация политик ретраев для HTTP запросов
